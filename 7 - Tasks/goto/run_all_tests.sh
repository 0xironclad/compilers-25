
WC=${WC-33}
EC=${EC-31}
HC=${HC-36}
SC=${SC-33}
MC=${MC-39}
OC=${OC-32}

HI="\e[${HC}m"
OK="\e[${OC}m"
ERR="\e[${EC}m"
SRC="\e[${SC}m"
OFF="\e[0m"

show_fails_only=0
#failfile="lastfails.txt"

# [ ! -f $failfile ] && echo -n "" >$failfile

verbose=1

oks=("ok")
errs=("lex" "syn" "sem" "err")
declare -a extensions
folder="tests"
used_custom_folder=0
show_full_help=0
show_sources=1

[ ! -f "tests" ] && [ `find ./* -maxdepth 0 -type d | grep -v autogenerated | wc -l` -eq 1 ] && used_custom_folder=1 && folder=`find ./* -maxdepth 0 -type d | grep -v autogenerated`

NO_USAGE=0
while [ $# -ge 1 ]; do
    # we found an arg, the user knows what he's doing
    NO_USAGE=1

    if [[ "$1" == *fail*only* ]]; then
	shift
#	[ ! -f "$failfile" ] && echo "Cannot show only fails: $failfile does not exist yet" && continue

        show_fails_only=1
        continue
    fi


    # if we found a number, we consider it the "min" argument
    if [[ "$1" =~ ^[0-9]+$ ]]; then
	MIN="$1"
	MAX="$1"
	[ $# -gt 1 ] && [[ "$2" =~ ^[0-9]+$ ]] && MAX="$2" && shift
	shift
	continue
    fi


    arg=$1
    shift

    [ "$arg" == "nosrc" ] && show_sources=0 && continue
    [ "$arg" == "quiet"  ] && verbose=0 && continue
    [ "$arg" == "help" ] && show_full_help=1 && continue

    if [ -d $arg ]; then
        folder="$arg"
        used_custom_folder=1
    else
        extensions+=($arg)
    fi    
done

# if no extensions are given, we use the default ones
[ ${#extensions} -eq 0 ] && extensions=("ok" "lex" "syn" "sem" "err") 


get_highlight() {
    is_ok_name=false
    is_err_name=false
    for item in "${oks[@]}"; do [[ "$1" =~ $item* ]] && is_ok_name=true && break; done
    for item in "${errs[@]}"; do [[ "$1" =~ $item* ]] && is_err_name=true && break; done

    if [ "$is_err_name" == true ]; then
        echo "${ERR}"
    elif [ "$is_ok_name" == true ]; then
        echo "${OK}"
    else
        echo "${OFF}"
    fi
}

add_to_fails_by_dir() {
    local item="$1"
    # Check if the item is already in the set
    if [[ ! " ${fails_by_dir[@]} " =~ " ${item} " ]]; then
        newidx=${#fails_by_dir[@]}
        fails_by_dir[$newidx]="$item"
    fi
}


set -o pipefail
make 2>&1 \
    | awk -v ok="${OC}" -v msg="${MC}" '/Extending rule/ {print "\033[" ok "m" $0 "\033[" msg "m"; next} {print}' \
    | awk -v err="${EC}" -v msg="${MC}" '/([Ee]rror)/ {print "\033[" err "m" $0 "\033[" msg "m"; next} {print}' \
    | awk -v warn="${WC}" -v msg="${MC}" '/([Ww]arning|[Rr]ule|[Cc]onflict|[Cc]annot)/ {print "\033[" warn "m" $0 "\033[" msg "m"; next} {print}'
errcode=$?
set +o pipefail

echo "-------------------------------"

[ $errcode -ne 0 ] && echo && echo -e "${ERR}Compilation error${OFF}, exiting" && exit $errcode


testidx=1
count=0
success_count=0
failure_count=0
declare -A fails
declare -A failcount_by_ext
fails_by_dir=()
if [ ! -d $folder ]; then
    echo
    echo -e "${ERR}Error: test folder ${HI}$folder ${ERR}doesn't exist${OFF}"
elif [ $show_full_help -eq 1 ]; then
    # do nothing here
    :
else
    declare -A ext_count
    for ext in ${extensions[@]}; do
        for infile in `find "$folder" -type f -regex ".*[.]$ext.*" | sort 2>/dev/null`; do
#	    [ ${show_fails_only} -eq 1 ] && [ ! `grep "$infile" "$failfile"` ] && echo -e "Skipping ${HI}previously OK file${OK} $infile${OFF}$prevfailinfo" && continue

            if [ -v MIN ]; then
                num=`basename $infile`
                num=${num%%.*}
                if [[ "$num" =~ ^[0-9]+$ ]]; then
                    [ "$num" -lt $MIN ] && continue
                    [ "$num" -gt $MAX ] && continue
                fi
            fi

            fullext="${infile##*.}"
            ((ext_count["$fullext"]++))

            namehighlight=$(get_highlight "$ext")
            hashcount=15

#            (( $verbose )) && echo
#            (( $verbose )) && printf "#%02d %s ${namehighlight}%s${OFF} %s/${namehighlight}%s${OFF}\n" "$testidx" "$ext" "$(printf '%0.sv' $(seq $(($hashcount-1-${#ext}))))" "`dirname $infile`" "`basename $infile`"

            set -o pipefail
            ./while $infile >/dev/null 2>&1
            errcode=$?
            set +o pipefail

            if (( $verbose )); then
	        if (( $show_sources )); then
	    	    errlines=`./while $infile 2>&1 | awk '{out=""; while (match($0, /[Ll]ine [0-9]+/)) {out = out (out ? "|" : "") substr($0, RSTART+5, RLENGTH-5); $0 = substr($0, RSTART+RLENGTH)}; printf "%s", out}'`
	    	    errtxt=`./while $infile 2>&1 | grep "(" | cut -d"(" -f2 | cut -d")" -f1`
	    	    echo -en "${SRC}"
		    nl -s ' | ' -w 2 $infile \
			| sed -E "s#^[ ]($errlines)([ ]\|[ ].*)#X \1\2#" \
			| awk -v hc="${HC}" -v ec="${EC}" -v sc="${SC}" -v txt="$errtxt" '{if ($0 ~ /^X/ && txt != "") {for(i=1; i<=NF; i++) if($i ~ txt) $i="\033[" hc "m" $i "\033[" ec "m"}; print}' \
			| awk -v ec="${EC}" -v sc="${SC}" '{if ($0 ~ /^X/) {$0=substr($0, 2); print "\033[" ec "m" $0 "\033[" sc "m"} else print $0;}'

#			| awk -v hc="${EC}" -v ec="${EC}" -v sc="${SC}" -v txt="$errtxt" '{if (txt != "") {gsub(txt, "\033[" hc "m" "AA" txt "BB" "\033[" ec "m", $0)}; print}'
#			| awk -v txt="$errtxt" '{if (txt != "") {for(i=1; i<=NF; i++) if($i ~ txt) $i="X" $i "Y"}; print}' \
#			| awk -v txt="$errtxt" '{if (txt != "") {found=0; for(i=1; i<=NF; i++) if(!found && $i ~ txt) { $i="X" $i "Y"; found=1} }; print}' \
	    	    echo -en "${OFF}"
    	    	    echo "-------------------------------"
	        fi

                ./while $infile 2>&1 \
                    | awk '/[Ee]rror/ { gsub(/\)/, ")\033[31m"); print "\033[31m" $0 "\033[0m" }' \
                    | awk '/[Ss]uccess/ {print "\033[32m" $0 "\033[0m"; next} {print}' \
                    | awk -v on="${HC}" '{if ($0 ~ /->/) {for(i=1;i<=NF;i++) if ($i ~ /^[a-z_0-9]+$/) $i="\033[" on "m"$i"\033[0m"} print}' \
                    | awk -v on="${HC}" '{gsub(/\([^)]*\)/, "\033[35m&\033[0m"); print}'
	    fi

            expectederr=0
            [ $namehighlight == "$ERR" ] && expectederr=1
            supposedto="execute successfully"
            [ $namehighlight == "$ERR" ] && supposedto="fail"
            whatitdid="executed successfully"
            [ $errcode -ne 0 ] && whatitdid="failed"
            if [ $errcode -eq $expectederr ]; then
                (( $verbose )) && printf "#%02d %s ${namehighlight}%s${OFF} %s/${namehighlight}%s${OFF} executed ${OK}with the expected outcome$OFF.\n" "$testidx" "$ext" "$(printf '%0.s^' $(seq $(($hashcount-1-${#ext}))))" "`dirname $infile`" "`basename $infile`"
                ((success_count++))
            else
                (( $verbose )) && printf "#%02d %s ${namehighlight}%s${OFF} ${ERR}Error:${OFF} %s/${namehighlight}%s${OFF} is supposed to ${namehighlight}$supposedto$OFF but it ${namehighlight}$whatitdid$OFF!\n" "$testidx" "$ext" "$(printf '%0.s^' $(seq $(($hashcount-1-${#ext}))))" "`dirname $infile`" "`basename $infile`"
                ((failure_count++))
                ((failcount_by_ext[$ext]++))
                newidx=${#fails[@]}
                fails[$newidx]="$infile"
		add_to_fails_by_dir `dirname $infile`
            fi

#            (( $verbose )) && echo

            ((count++))
            ((testidx++))
        done
    done

    echo

    [ $used_custom_folder -eq 1 ] && echo && echo -e "Used custom test root folder ${HI}$folder${OFF}"
    [ ${show_fails_only} -eq 1 ] && [ -f "$failfile" ] && echo -e "Showed ${HI}only previously failed${OFF} test cases"

    succtxt="${OK}$success_count successes${OFF}"
    [ $success_count -eq 0 ] && succtxt=""
    midtxt=", "
    [ $success_count -eq 0 -o $failure_count -eq 0 ] && midtxt=""
    failtxt="${ERR}$failure_count failures${OFF}"
    [ $failure_count -eq 0 ] && failtxt=""
    testsucctxt=" ($succtxt$midtxt$failtxt)"
    [ $count -eq 0 ] && testsucctxt=""
    echo -e "Ran ${HI}$count${OFF} test cases$testsucctxt in ${HI}$folder${OFF} with extensions ${HI}$(IFS=,; echo "${extensions[*]}")${OFF}"

    for ext in "${extensions[@]}"; do
        if [[ -n "${ext_count[$ext]}" ]]; then
            namehighlight=$(get_highlight "$ext")
            printf "  ${namehighlight}%2d${OFF} files: ${namehighlight}.$ext${OFF}\n" "${ext_count[$ext]}"
        fi
    done
fi

for ext in "${!ext_count[@]}"; do
    if [[ ! " ${extensions[@]} " =~ "$ext" ]]; then
        namehighlight=$(get_highlight "$ext")
        printf "  ${namehighlight}%2d${OFF} files: ${namehighlight}.$ext${OFF}\n" "${ext_count[$ext]}"
    fi
done



if [ $failure_count -ne 0 ]; then
    echo "Failed test cases: "
    for faildiridx in "${!fails_by_dir[@]}"; do
        faildir=${fails_by_dir[$faildiridx]}
        echo -en "- in ${HI}$faildir${ERR}: "

        for failidx in "${!fails[@]}"; do
    	    fail=${fails[$failidx]}
    	    [ `dirname $fail` != "$faildir" ] && continue

            ext="${fail##*.}"
            namehighlight=$(get_highlight "$ext")
            echo -en "${namehighlight}`basename $fail` ${OFF}"
	done
	
	echo
    done

    echo
fi


if [ $show_full_help -eq 0 ]; then
    echo
    echo -e "Note: run ${OK}$0${HI} help${OFF} to see detailed usage options"
else
    echo -e "Detailed usage:"
    echo -e "${OK}$0${HI} lexical-error${OFF}   | Run tests with the given extension"
    echo -e "${OK}$0${HI} lex${OFF}             | Abbreviate to just the prefix (e.g. ${HI}ok${OFF}, ${HI}lex${OFF}, ${HI}syn${OFF}, ${HI}sem${OFF}, ${HI}err${OFF})"
    echo -e "${OK}$0${HI} lex ok syn${OFF}      | ... or even use several of them"
    echo -e "${OK}$0${HI} mytests syn${OFF}     | Use tests from a custom path"
    echo -e "${OK}$0${HI} syn mytests lex${OFF} | ... the first folder is considered as the path"
    echo -e "${OK}$0${HI} lex 3${OFF}           | Run only a specific test"
    echo -e "${OK}$0${HI} lex 3 4${OFF}         | ... or a range of them"
    echo -e "${OK}$0${HI} ok mytests 3 4${OFF}  | ... combined with other options"
    echo -e "${HI}HC=33 ${OK}$0${OFF}           | Use a custom highlight (${HI}31${OFF}..${HI}36${OFF})"
    echo -e "${OK}$0${HI} failsonly${OFF}       | Show only previously failed cases (listed in ${HI}$failfile${OFF})"
    echo -e "${OK}$0${HI} nosrc${OFF}           | Does not print the source code for each case"
    echo -e "${HI}SC=34 ${OK}$0${OFF}           | Use a custom source highlight (${HI}31${OFF}..${HI}36${OFF})"
    echo -e "${OK}$0${HI} quiet${OFF}           | Fewer printouts"
fi
